"""
cyclic_group.py
---------------
Models round-robin scheduling as the cyclic subgroup of S_n
generated by the n-cycle c = (1 2 3 ... n).

Verifies:
    - ⟨c⟩ is a subgroup of S_n
    - |⟨c⟩| = n
    - c^n = e  (order of c is n)
    - ⟨c⟩ ≅ Z_n  (isomorphism check)
    - The action of ⟨c⟩ on P is transitive (starvation freedom)
    - ⟨c⟩ is abelian

Depends on: permutations.py
"""

import math
from src.permutations import (
    generate_Sn,
    identity,
    compose,
    inverse,
    power,
    order as perm_order,
    cycle_notation_str,
    is_subgroup,
)



# Constructing the Round-Robin Cycle


def make_n_cycle(n: int) -> dict:
    """
    Construct the n-cycle c = (1 2 3 ... n).

    c(i) = i + 1  for i = 1, ..., n-1
    c(n) = 1

    This is the generator of the round-robin cyclic subgroup.
    """
    sigma = {}
    for i in range(1, n):
        sigma[i] = i + 1
    sigma[n] = 1
    return sigma



# Generating the Cyclic Subgroup


def generate_cyclic_subgroup(n: int) -> list:
    """
    Generate ⟨c⟩ = { e, c, c², ..., c^(n-1) } for the n-cycle c.

    Repeatedly composes c with itself until returning to identity.

    Returns:
        List of permutations in ⟨c⟩, starting with identity.
    """
    c       = make_n_cycle(n)
    e       = identity(n)
    current = dict(e)
    elements = []

    for _ in range(n):
        elements.append(dict(current))
        current = compose(current, c)

    return elements



# Transitivity Check


def is_transitive(subgroup: list, n: int) -> bool:
    """
    Check whether subgroup acts transitively on P = {1, ..., n}.

    Transitive means: for any i, j ∈ P, there exists σ ∈ subgroup
    such that σ(i) = j.

    Transitivity ↔ starvation freedom in scheduling terms.
    """
    P = set(range(1, n + 1))
    for i in P:
        reachable = {sigma[i] for sigma in subgroup}
        if reachable != P:
            return False
    return True



# Abelian Check


def is_abelian(subgroup: list) -> bool:
    """
    Check whether subgroup is abelian (commutative).

    σ ∘ τ = τ ∘ σ  for all σ, τ ∈ subgroup.
    """
    for s in subgroup:
        for t in subgroup:
            if compose(s, t) != compose(t, s):
                return False
    return True



# Isomorphism with Z_n


def check_isomorphism_Zn(cyclic: list, n: int) -> bool:
    """
    Verify ⟨c⟩ ≅ Z_n by checking the group tables match.

    Strategy: map c^k ↦ k ∈ Z_n and verify the homomorphism property.
    φ(c^j ∘ c^k) = φ(c^(j+k mod n)) = (j+k) mod n = φ(c^j) + φ(c^k) mod n
    """
    c = make_n_cycle(n)

    # Build index map: permutation → its power k
    index_map = {}
    current = identity(n)
    for k in range(n):
        index_map[tuple(sorted(current.items()))] = k
        current = compose(current, c)

    # Verify homomorphism: φ(σ ∘ τ) = (φ(σ) + φ(τ)) mod n
    for s in cyclic:
        for t in cyclic:
            st      = compose(s, t)
            phi_s   = index_map[tuple(sorted(s.items()))]
            phi_t   = index_map[tuple(sorted(t.items()))]
            phi_st  = index_map[tuple(sorted(st.items()))]
            if phi_st != (phi_s + phi_t) % n:
                return False
    return True



# Verification


def verify_cyclic_subgroup(n: int, verbose: bool = True) -> bool:
    """
    Full verification of the round-robin cyclic subgroup for given n.

    Checks:
        1. ⟨c⟩ is a valid subgroup of S_n
        2. |⟨c⟩| = n
        3. c^n = e  (order of generator is n)
        4. ⟨c⟩ ≅ Z_n  (isomorphism)
        5. Action on P is transitive  (starvation freedom)
        6. ⟨c⟩ is abelian

    Returns:
        True if all checks pass.
    """
    cyclic = generate_cyclic_subgroup(n)
    c      = make_n_cycle(n)
    e      = identity(n)

    if verbose:
        print(f"\n{'='*55}")
        print(f"Cyclic Subgroup Verification  —  n = {n}")
        print(f"{'='*55}")

    results = []

    # 1. Subgroup axioms
    sub_check = is_subgroup(cyclic, n)
    results.append(sub_check)
    if verbose:
        status = "✓" if sub_check else "✗"
        print(f"  [{status}] ⟨c⟩ is a subgroup of S_{n}")

    # 2. Order
    order_check = len(cyclic) == n
    results.append(order_check)
    if verbose:
        status = "✓" if order_check else "✗"
        print(f"  [{status}] |⟨c⟩| = {len(cyclic)}  (expected {n})")

    # 3. c^n = e
    cn          = power(c, n)
    power_check = cn == e
    results.append(power_check)
    if verbose:
        status = "✓" if power_check else "✗"
        print(f"  [{status}] c^{n} = e  →  {cycle_notation_str(cn)}")

    # 4. Isomorphism with Z_n
    iso_check = check_isomorphism_Zn(cyclic, n)
    results.append(iso_check)
    if verbose:
        status = "✓" if iso_check else "✗"
        print(f"  [{status}] ⟨c⟩ ≅ Z_{n}  (homomorphism verified)")

    # 5. Transitivity
    trans_check = is_transitive(cyclic, n)
    results.append(trans_check)
    if verbose:
        status = "✓" if trans_check else "✗"
        print(f"  [{status}] Action on P is transitive  (starvation-free)")

    # 6. Abelian
    ab_check = is_abelian(cyclic)
    results.append(ab_check)
    if verbose:
        status = "✓" if ab_check else "✗"
        print(f"  [{status}] ⟨c⟩ is abelian")

    return all(results)



# Display Utilities


def print_cyclic_subgroup(n: int) -> None:
    """
    Print all elements of ⟨c⟩ with their scheduling interpretation.
    """
    cyclic = generate_cyclic_subgroup(n)

    print(f"\nRound-robin schedules for {n} processes  —  ⟨c⟩ ≅ Z_{n}:\n")
    for k, sigma in enumerate(cyclic):
        queue = list(sigma.values())
        print(f"  c^{k} = {cycle_notation_str(sigma):<20}  →  queue {queue}")


def print_fraction_of_Sn(n: int) -> None:
    """
    Print how large ⟨c⟩ is relative to S_n.
    """
    sn_order     = math.factorial(n)
    cyclic_order = n
    fraction     = cyclic_order / sn_order * 100
    print(f"  n={n}:  |⟨c⟩| / |S_{n}| = {cyclic_order} / {sn_order} "
          f"= {fraction:.4f}%")



# Quick Verification


if __name__ == "__main__":
    print("Cyclic Subgroup — Round-Robin Scheduling Verification\n")

    all_passed = True
    for n in range(2, 7):
        passed = verify_cyclic_subgroup(n, verbose=True)
        all_passed = all_passed and passed

    print(f"\n{'='*55}")
    if all_passed:
        print("All verifications passed. ✓")
    else:
        print("Some verifications FAILED. ✗")

    # Show round-robin schedules for n=4
    print_cyclic_subgroup(n=4)

    # Show how small ⟨c⟩ is compared to S_n
    print("\nRound-robin as a fraction of full scheduling space:\n")
    for n in range(2, 7):
        print_fraction_of_Sn(n)