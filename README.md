# Symmetry and Scheduling — OS Synchronization through Permutation Groups

A computational and structural study of operating system synchronization modeled as symmetry reduction in permutation groups. This project formalizes process scheduling as elements of S_n, mutual exclusion as stabilizer subgroups, and round-robin fairness as cyclic subgroup action — with executable verification in Python.

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Python 3.9+](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/downloads/)
[![Type: Academic](https://img.shields.io/badge/type-academic-lightgrey.svg)]()
[![Year: 2026](https://img.shields.io/badge/year-2026-informational.svg)]()

**Author:** Om Pranab Mohanty  
**Repository:** [github.com/04pranab/os-symmetry-synchronization](https://github.com/04pranab/os-symmetry-synchronization)

---

## Table of Contents

- [Background](#background)
- [Formal Model](#formal-model)
- [The Four Claims](#the-four-claims)
- [Repository Structure](#repository-structure)
- [Installation](#installation)
- [Usage](#usage)
- [Verified Results](#verified-results)
- [Limitations](#limitations)
- [References](#references)
- [License](#license)

---

## Background

Synchronization mechanisms in operating systems — mutual exclusion, round-robin scheduling, deadlock — are conventionally described in operational terms: semaphores, queues, lock/unlock protocols. This description is effective for implementation but does not expose the underlying structure of the scheduling space.

This project proposes a structural reading. The set of all possible orderings of `n` concurrent processes forms the symmetric group `S_n`. Synchronization constraints, viewed this way, are not behavioral rules but restrictions on which elements of `S_n` are admissible — and these restrictions correspond to standard algebraic substructures: stabilizer subgroups, cyclic subgroups, and the trivial element.

The project makes this correspondence precise and verifies it computationally for small `n` using first-principles Python implementations.

---

## Formal Model

Let `P = {1, 2, ..., n}` be a set of `n` concurrent processes.

A **schedule** is a bijection `σ: P → P`, representing a total ordering in which processes are executed. The set of all such bijections is the symmetric group `S_n`, which has order `n!`.

A **synchronization constraint** is any restriction on the set of admissible schedules. The central observation of this project is that classical constraints define subsets of `S_n` that are, in fact, algebraically structured — specifically, subgroups.

---

## The Four Claims

### 1 — Unrestricted Scheduling is `S_n`

Without any constraints, every permutation of `n` processes is a valid schedule. The full scheduling space is `S_n` with `|S_n| = n!`.

### 2 — Mutual Exclusion as a Stabilizer Subgroup

When a process holds a critical resource and no other process may interleave with it, the admissible schedules are exactly those that fix a designated element. This is the stabilizer subgroup:

```
Stab(x) = { σ ∈ S_n | σ(x) = x }
```

`Stab(x)` is a subgroup of `S_n` of order `(n-1)!`. Mutual exclusion is a fixed-point constraint on the scheduling space.

### 3 — Round-Robin Scheduling as a Cyclic Subgroup

The round-robin policy assigns processor time in the repeating cycle `1 → 2 → ... → n → 1`. This is the orbit of the `n`-cycle `c = (1 2 ... n)` under repeated composition:

```
⟨c⟩ = { e, c, c², ..., c^(n-1) } ≅ Z_n
```

Round-robin is the cyclic subgroup of order `n` generated by this single permutation.

### 4 — Deadlock as the Identity Element

In a deadlock, no process can advance — every process is waiting on another. The only permutation that maps every process to itself (no forward progress) is the identity `e ∈ S_n`. Deadlock corresponds to the collapse of all scheduling action to the trivial element.

---

## Repository Structure

```
os-symmetry-synchronization/
│
├── README.md
├── LICENSE
├── requirements.txt
│
├── theory/                              # Mathematical notes
│   ├── 01_formal_model.md
│   ├── 02_mutual_exclusion_theorem.md
│   ├── 03_cyclic_scheduling.md
│   └── 04_deadlock_as_trivial_action.md
│
├── src/                                 # Python source
│   ├── permutations.py                  # S_n generation and operations
│   ├── stabilizer.py                    # Stabilizer subgroup computation
│   ├── cyclic_group.py                  # Cyclic subgroup generation
│   └── scheduler_model.py              # Unified model
│
├── notebooks/                           # Jupyter notebooks
│   ├── 01_generate_Sn.ipynb
│   ├── 02_compute_stabilizer.ipynb
│   └── 03_visualize_cyclic_action.ipynb
│
└── Pre-Journal Draft/
│   ├── OS_Synchronization_as_Symmetry_Restrictions_in_Sn.pdf
│   ├── references.bib
    └── main.tex
```
** *Codes are generated by help of LLMs but `Human Verified`.* ✌

---

## Installation

```bash
git clone https://github.com/04pranab/os-symmetry-synchronization.git
cd os-symmetry-synchronization
pip install -r requirements.txt
```

Dependencies: `numpy`, `matplotlib`, `jupyter`, `networkx`, `sympy`. No computer algebra system is used — all group-theoretic operations are implemented from scratch.

---

## Usage

```python
from src.permutations import generate_Sn
from src.stabilizer import compute_stabilizer
from src.cyclic_group import generate_cyclic_subgroup

# All schedules for 3 processes
S3 = generate_Sn(3)
print(len(S3))           # 6  →  3! = 6

# Mutual exclusion: stabilizer of process 0
stab = compute_stabilizer(S3, fixed_point=0)
print(len(stab))         # 2  →  (3-1)! = 2

# Round-robin for 4 processes
cycle = generate_cyclic_subgroup(n=4)
print(len(cycle))        # 4  →  |Z_4| = 4
```

Run the notebooks for step-by-step walkthroughs with visualizations:

```bash
jupyter notebook notebooks/
```

---

## Verified Results

All four claims verified computationally for `n ∈ {2, 3, 4, 5, 6}`:

| n | \|S_n\| | \|Stab(x)\| | \|⟨c⟩\| | Deadlock |
|---|---------|-------------|---------|---------|
| 2 | 2       | 1           | 2       | e       |
| 3 | 6       | 2           | 3       | e       |
| 4 | 24      | 6           | 4       | e       |
| 5 | 120     | 24          | 5       | e       |
| 6 | 720     | 120         | 6       | e       |

---

## Limitations

- The model uses total orderings. Real schedulers involve preemption, priorities, and partial orders not captured by `S_n`.
- The deadlock–identity correspondence is conceptual. It illustrates the idea but is not a theorem in the strong sense.
- No new mathematical results are claimed. This is a formalization and verification exercise.

---

## References

- Silberschatz and Galvin, *“Operating System Concepts”*, Wiley-India, International Student Version, 8th Ed., 2010
- Joseph A. Gallian, Contemporary Abstract Algebra, Cengage Learning , 2017, 8th Edition.

---

## License

This project is licensed under the MIT License. See [LICENSE](LICENSE) for details.
