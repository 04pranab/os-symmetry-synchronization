# 03 — Round-Robin Scheduling as a Cyclic Subgroup

## Formalizing the Round-Robin Policy

This document develops Claim 3: that round-robin scheduling corresponds to the cyclic subgroup of `S_n` generated by the `n`-cycle, isomorphic to `Z_n`.

Prerequisites: definitions from `01_formal_model.md` — symmetric group, subgroup, group action, orbits.

---

## 1. The Problem in OS Terms

Round-robin is one of the simplest and most widely used CPU scheduling algorithms. Processes are arranged in a circular queue and each is given a fixed time quantum in repeating cyclic order:

```
1 → 2 → 3 → ... → n → 1 → 2 → 3 → ...
```

No process is prioritized. Every process gets equal and periodic access. The question is: what subgroup of `S_n` captures this policy exactly?

---

## 2. The n-Cycle

**Definition 2.1 (n-cycle).** The *round-robin permutation* is the `n`-cycle:

```
c = (1  2  3  ...  n)
```

defined by:

```
c(i) = i + 1   for i = 1, 2, ..., n-1
c(n) = 1
```

This permutation sends each process to the next one in the cycle, and wraps the last process back to the first.

**Example (n = 4):**

```
c = (1 2 3 4)

c(1) = 2,  c(2) = 3,  c(3) = 4,  c(4) = 1
```

One application of `c` advances the schedule by one step in the round-robin order.

---

## 3. The Cyclic Subgroup Generated by c

**Definition 3.1 (Cyclic Subgroup).** The *cyclic subgroup generated by `c`* is:

```
⟨c⟩ = { c^k | k ∈ Z } = { e, c, c², c³, ..., c^(n-1) }
```

where `c^k` means applying `c` exactly `k` times, and `c^0 = e`.

**Proposition 3.2.** The order of `c` is `n`, i.e., `c^n = e` and no smaller positive power returns to the identity.

*Proof.* Applying `c` exactly `n` times to any process `i`:

```
c^n(i) = i + n  (mod n)  = i
```

So `c^n = e`. For any `1 ≤ k < n`, `c^k(1) = 1 + k ≠ 1`, so `c^k ≠ e`. Therefore the order of `c` is exactly `n`. ∎

**Corollary 3.3.** `|⟨c⟩| = n`.

---

## 4. The Elements of ⟨c⟩

Each power of `c` corresponds to a specific rotation of the process queue:

```
c⁰ = e         →  [1, 2, 3, ..., n]     (no rotation)
c¹ = c         →  [2, 3, 4, ..., 1]     (rotate left by 1)
c²             →  [3, 4, 5, ..., 2]     (rotate left by 2)
  ⋮
c^(n-1)        →  [n, 1, 2, ..., n-1]   (rotate left by n-1)
```

Each element of `⟨c⟩` is a distinct rotation. These are all the admissible schedules under a strict round-robin policy — each is just the queue starting from a different process.

---

## 5. Isomorphism with Z_n

**Theorem 5.1.** `⟨c⟩ ≅ Z_n`

*Proof.* Define the map:

```
φ : Z_n → ⟨c⟩,    φ(k) = c^k
```

- **Well-defined:** `c^k` is uniquely determined for each `k ∈ {0, 1, ..., n-1}`.
- **Homomorphism:** `φ(k + l) = c^(k+l) = c^k ∘ c^l = φ(k) ∘ φ(l)`.
- **Bijection:** distinct values of `k` give distinct powers of `c` (since ord(c) = n).

Therefore `φ` is a group isomorphism and `⟨c⟩ ≅ Z_n`. 

---

## 6. ⟨c⟩ is a Subgroup of S_n

**Proposition 6.1.** `⟨c⟩ ≤ S_n`

*Proof.* Standard result: any cyclic subgroup generated by an element of a group is a subgroup. Explicitly:

- **Identity:** `c⁰ = e ∈ ⟨c⟩`. ✓
- **Closure:** `c^j ∘ c^k = c^(j+k mod n) ∈ ⟨c⟩`. ✓
- **Inverses:** `(c^k)⁻¹ = c^(n-k) ∈ ⟨c⟩`. ✓  

Note that `|⟨c⟩| = n` divides `|S_n| = n!`, consistent with Lagrange's theorem. ✓

---

## 7. Structural Properties

**Proposition 7.1.** `⟨c⟩` acts transitively on `P`.

*Proof.* For any two processes `i, j ∈ P`, we need a `k` such that `c^k(i) = j`. Since `c^k(i) = i + k (mod n)`, choosing `k = j - i (mod n)` works. Every process is reachable from every other by some power of `c`. 

**OS interpretation:** Transitivity means round-robin is **fair** — every process will eventually be scheduled regardless of the starting state. No process can be indefinitely starved.

**Proposition 7.2.** `⟨c⟩` is abelian.

*Proof.* `c^j ∘ c^k = c^(j+k) = c^k ∘ c^j`. Addition of integers is commutative. 

**OS interpretation:** The order in which round-robin steps are composed does not matter — this reflects the symmetric, non-preferential nature of the policy.

---

## 8. Comparison with S_n

The round-robin subgroup `⟨c⟩` is a very small piece of the full scheduling space:

```
|⟨c⟩|   =   n
|S_n|    =   n!
```

The ratio `|S_n| / |⟨c⟩| = (n-1)!` tells us how many cosets `⟨c⟩` partitions `S_n` into. Most schedules in `S_n` are not round-robin — round-robin is a maximally constrained, maximally fair, minimal subgroup.

| n | `\|S_n\|` | `\|⟨c⟩\|` | Fraction of S_n |
|---|-----------|-----------|-----------------|
| 2 | 2         | 2         | 100%            |
| 3 | 6         | 3         | 50%             |
| 4 | 24        | 4         | 16.7%           |
| 5 | 120       | 5         | 4.2%            |
| 6 | 720       | 6         | 0.83%           |

Round-robin becomes an increasingly restrictive constraint as `n` grows.

---

## 9. Worked Example — n = 4

```
c = (1 2 3 4)

⟨c⟩ = { e, c, c², c³ }

e   : 1→1, 2→2, 3→3, 4→4   →  schedule [1, 2, 3, 4]
c   : 1→2, 2→3, 3→4, 4→1   →  schedule [2, 3, 4, 1]
c²  : 1→3, 2→4, 3→1, 4→2   →  schedule [3, 4, 1, 2]
c³  : 1→4, 2→1, 3→2, 4→3   →  schedule [4, 1, 2, 3]
```

These are the four distinct rotations of the process queue. In round-robin scheduling, each time quantum advances the system from one element of `⟨c⟩` to the next.

Check: `c⁴ = e` ✓, `|⟨c⟩| = 4 = n` ✓, `4` divides `24 = 4!` ✓

---

## 10. Summary

| Property | Value |
|----------|-------|
| Generator | `c = (1 2 3 ... n)` |
| Subgroup | `⟨c⟩ = { e, c, c², ..., c^(n-1) }` |
| Order | `n` |
| Isomorphic to | `Z_n` |
| Action on P | Transitive (every process reachable) |
| Commutativity | Abelian |
| OS interpretation | All rotations of the round-robin queue |

---

## 11. Computational Verification

The source file `src/cyclic_group.py` implements this:

1. Construct the `n`-cycle `c` as a permutation
2. Generate `⟨c⟩` by repeated composition until returning to `e`
3. Verify `|⟨c⟩| = n`
4. Verify `c^n = e`
5. Verify the subgroup axioms
6. Verify transitivity of the action on `P`

See also: `notebooks/03_visualize_cyclic_action.ipynb` for a visual representation of the cyclic action.

---

*Previous: [02 — Mutual Exclusion as a Stabilizer Subgroup](02_mutual_exclusion_theorem.md)*  
*Next: [04 — Deadlock as the Trivial Action](04_deadlock_as_trivial_action.md)*